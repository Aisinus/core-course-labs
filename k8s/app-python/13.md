### Task 2.1

```bash
kubectl get po
NAME                          READY   STATUS      RESTARTS     AGE
app-python-77d84458f7-nh7nt   1/1     Running     1 (9d ago)   9d
post-install-hook             0/1     Completed   0            30d
pre-install-hook              0/1     Completed   0            30d

kubectl get sts
NAME         READY   AGE
app-python   1/1     3m3s
vault        1/1     4h11m

kubectl get svc
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
app-python   NodePort    10.109.55.121   <none>        5000:32598/TCP   9d
kubernetes   ClusterIP   10.96.0.1       <none>        443/TCP          38d

kubectl get pvc
No resources found in default namespace.
```


```bash
kubectl exec pod/app-python-77d84458f7-nh7nt -- cat visits
72%                                                                                                  
```

#### Explanation:
Currently, my values.yaml specifies a minimum number of replicas of 1. And since my application is not subjected to high loads Minikube does not raise additional replicas of my application. Because of this there is only 1 Pod of the application. 


#### Task 2.2

Ordering guarantees are unnecessary for this application because it is stateless. In a stateless application, each request is independent of others. The application does not need to remember any state between requests, so the order in which pods are started or terminated does not matter.

To instruct the StatefulSet controller to launch or terminate all Pods in parallel, you can set the .spec.podManagementPolicy to Parallel in your StatefulSet configuration. By default, it is set to OrderedReady, which means the pods are started one at a time in their StatefulSet order.

I need to add:
```yaml
spec:
  podManagementPolicy: Parallel
  ...
```
Into my statefulset.yaml. This change will make Kubernetes start and stop all pods in the StatefulSet simultaneously, rather than waiting for each one to be ready before starting the next.